## Клиентский бойлерплейт на [Next.js](https://nextjs.org/docs/getting-started)

### Старт

- `yarn install`
- находим по проекту вставку `-boilerplate-` и заменяем ее (или в том же файле) на те значения, которые необходимы
- `yarn dev` - дев-сборка с HMR и SSR всегда
- `yarn compile:<env>` - сборка проекта и его запуск в соответствующем окружении (`env = development | production`)

### Конфигурация

Дополнительную настройку приложения можно производить по аналогии с тем, что уже написано в `next.config.js`. **Важное замечание:** вся уникальная информация для приложения, которая зависит от окружения сборки, должна быть изолирована на этапе конфигурации и сборки приложения в `config/env`.

#### Роутинг и страницы

Базовая схема маршрутизации в next'е базируется на файловой структуре папки `pages`. Из-за этого возникает ряд проблем, таких как создание лишних урлов для сторонних файлов в той же папке (например, файла стилей и контроллера) и костыльная возможность переиспользования страниц через реэкспорт. Чтобы исправить это, был выбран способ агрегации всех страниц, как контейнеров, в соответствующей папке (`src/containers`) с реэкспортом в страницы-контейнера в необходимом файле папки `pages` (см. `src/containers/LoginPage` и `pages/login/index.tsx`)

### Сервисы

В процессе построения приложения необходимо обеспечить изоляцию скоупа при каждом запросе пользователя. Для этого все сервисы инициализируются с помощью `ServicesManager`. Каждый сервис наследуется от базового класса сервиса, который принимает ссылку на корневой менеджер и сохраняет ее. Таким способом обеспечивается доступ к другим сервисам из какого-либо сервиса, контроллера или плагина. Для получения сервисов в самом компоненте имеются хук и хок.

#### GraphQL

Работа с апи gql-сервиса происходит с помощью адаптера [apollo](https://www.apollographql.com/docs/react/). Для удобства используется кодогенерация (`yarn schema:generate-types`), которую необходимо запускать после каждого обновления схемы на сервере, и плагин для `VS Code`. Для этого нужно установить расширение для работы с gql [Apollo GraphQL](https://marketplace.visualstudio.com/items?itemName=apollographql.vscode-apollo) (не забывайте после генерации схемы [обновлять ее в плагине](https://github.com/apollographql/apollo-tooling/tree/master/packages/vscode-apollo#troubleshooting)).

Хуки apollo будут автоматически резолвиться на сервере, и их результат будет сериализован после рендереинга приложения в кеш. Для кеширования запросов клиента apollo необходимо дождаться выполнения запроса в контроллере или на странице. Для этого нужно инкапсулировать всю асинхронную логику в методе `getInitialProps` страницы (см. `pages/login`).

## Backend API - GraphQL
Для работы с GraphQL используется сервис [Apollo](https://www.apollographql.com/docs/react/) и сервис-надстройка над ним для удобства оперирования с экшенами.
Чтобы использовать типизацию `gql`, нужно сначала сгенерировать gql-типы на основании схемы, которую предоставляет backend, и на основании самих экшенов, которые описываются в отдельной папке (`lib/gql`). Для этого имеется скрипт `schema:generate-types`.
Для использования самих экшенов есть сервис [`GraphglAPI`](src/lib/services/graphqlAPI.ts). Он нужен в основном для инкапсуляции логики обработки ошибок исполнения экшна, выбрасывания оповещений и переключения состояний. Для его использования нужно генерировать экшны с помощью отдельного скрипта - `gql:generate-configs`. Формат описания экшенов должен совпадать с [базовым типом `TActionConfig`](scripts/generateGQLConfigs/types.ts) и находиться в [соответствующем конфиге](src/lib/gqlConfig/config.ts).

`enum`-списки в чистом виде из сгенерированных типов лучше избегать, потому что при добавлении в них новых значений на фронте нужно сразу же фиксить коллизии, если используется где-то проход по ключам этого списка. Поэтому нужно ручками задавать перечисление в константе (это важно) и уже потом реиспользовать.

#### Управление состоянием

Для управления состоянием используется [mobx](https://mobx.js.org/README.html) с оберткой [для реакта](https://github.com/mobxjs/mobx-react). Для нормальной регидратации приложения и стора необходимо, чтобы каждый из дочерних сторов, относительно родительского, можно было сериализовать. Поэтому при добавлении новой сущности в корневой стор необходимо имплементировать базовый публичный метод `serialize` (см. `CStore` в `src/lib/store/types`), который вернет нативный js-объект с наблюдаемыми св-вами. Помимо этого новый стор необходимо добалять в св-во `childStores` корневого стора.

### Стилизация

Для стилизации используется [react-jss](https://cssinjs.org/react-jss/?v=v10.0.4). В текущей версии имеются проблемы с типизацией основного хока, поэтому был написан поверх него обретка, которая находится в `src/lib/HOCs/withStyles`. Сигнатура ф-ции такая же, как и в исходной имплементаци.

### Шрифты

Для загрузки шрифтов используется nextjs-плагин, который добавляет соответствующий лоадер в конфиг вебпака. Если локальные шрифты не нужны, то данный плагин можно убрать.

### Линтинг

Поскольку Next на текущий момент [не поддерживает линтинг `eslint`-ом](https://github.com/zeit/next.js/issues/7936#issuecomment-568508782), то ситуация складывается следующим образом:

- в рантайме линтинг происходит с помощью `tslint`;
- в редакторе, например VSC, нужно использовать `eslint`, предварительно **отключив `tslint`-плагин**;
- на прекоммите линтинг происходит так же с помощью `eslint`.
  ESLint предпочтителен, поскольку в нем поддерживаются правила для линтинга хуков, чего нет в TSLint. Если в `.eslintrc.js` происходят изменения, то они должны соотвеnствовать изменениям в `tslint.json`, и наоборот.

## Контроллеры

Если компонент реализуют в себе сложную логику, эту логику необходимо вынести на уровень контроллера. Это позволит разбить общее полотно кода на часть визуализации и часть с логикой (\*VC-подход). Для этого в утилитах контейнера имеется функционал, который позволяет:

- инициализировать контекст контроллера;
- создать хук и хок для получения контроллера;
- создать хук и хок для получения инстансов подконтроллеров по их классам;

Все это находится в утилите [`controllerHelpersBuilder`](src/lib/utils/controllerHelpersBuilder/index.ts). Пример использования данной утилиты вы можете найти на странице [`Example`](src/containers/ExamplePage/index.tsx).

## Подконтроллеры

Подконтроллеры существуют для того, чтобы разбивать контроллер на логические части для удобства чтения и редактирования кода. Кроме того, разбиение контроллера позволяет управлять его подконтроллерами (добавлять контроллер в пул подконтроллеров, если он необходим для использования компонента и соответственно удалять его, если работа с этой частью компонента завершена)

Для управления подконтроллерами, необходимо, чтобы родительский и дочерние контроллеры наследовались от [`BaseController`](src/lib/controller/base.ts). У базового класса контроллера существует несколько необходимых для этого методов, их описание есть внутри. Основное:

- подконтроллер хранит в себе ссылки на родительский (`parentController`) и корневой (`rootController`) контроллеры
- метод `addSubController` - добавляет подконтроллер;
- метод `removeSubControllerInstance` - удаляет инстанс подконтроллера из пула по его классу;
- `onCreate`, `onDestroy` - колбеки, которые вызываются соответственно сразу после добавления и прямо перед удалением подконтроллера

Контроллеры имеют статическое поле `NAME`, которое должно являться литералом, чтобы типизация при подключении подконтроллеров в компонент работала корректно.

Имена подконтроллеров хранятся в dot-нотации, т.е. `rootName.parentName.name`, это необходимо для случаев когда в дереве подконтроллеров в разных местах могут существовать контроллеры с одинаковым собственным названием. Для генерации имени подконтроллера исходя из родительских и наоборот для получения всех имен контроллеров из последовательности существует форматтер [`nameSubControllers`](src/lib/utils/formatters/nameSubControllers.ts).

Статические поля подконтроллера (в том числе имя) должны быть объявлены в отдельном файле и затем импортированы в контроллер для того, чтобы избежать циклических зависимостей при сборке.

Для использования подконтроллеров в компонентах в утилиту [`controllerHelpersBuilder`](src/lib/utils/controllerHelpersBuilder/index.ts) была добавлена генерация соответствующих хука и хока.

Пример реализации подконтроллера есть на странице [`Example`](src/containers/ExamplePage/index.tsx).
