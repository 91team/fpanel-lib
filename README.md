# Клиентский бойлерплейт

## Старт

- `yarn install`
- создать необходимые `env`-файлы по примеру (`.env.example`):
  - `.env.development` - используется для `dev` сборки
  - `.env.production` - используется для `production` сборки

## Скрипты

- `yarn build` - сборка ассетов для `production` сборки
- `yarn lint` - линтинг
- `yarn schema:generate-types` - генерация типов для GraphQL (необходимо активное подключение к gql-сервису, адрес которого указан в `codegen.yml`)
- `yarn gql:generate-configs` - генерация api для GraphQL (по конфигу `src/lib/gqlConfig/config.ts`)
- `yarn figma:generate-resources` - генерация ресурсов из фигмы
- `yarn dev` - запуск дев-сервера
- `yarn serve` - запуск сервера для `production` ассетов

## Роутинг и страницы

## Сервисы

Создаются внутри `ServicesManager` и по сути является глобальной сущностью. Сервис можно получить в любом месте через функцию `getService`.

## Backend API - GraphQL

Для работы с GraphQL используется сервис [Apollo](https://www.apollographql.com/docs/react/) и сервис-надстройка над ним для удобства оперирования с экшенами.
Чтобы использовать типизацию `gql`, нужно сначала сгенерировать gql-типы на основании схемы, которую предоставляет backend, и на основании самих экшенов, которые описываются в отдельной папке (`lib/gql`). Для этого имеется скрипт `schema:generate-types`.
Для использования самих экшенов есть сервис [`GraphglAPI`](src/lib/services/graphqlAPI.ts). Он нужен в основном для инкапсуляции логики обработки ошибок исполнения экшна, выбрасывания оповещений и переключения состояний. Для его использования нужно генерировать экшны с помощью отдельного скрипта - `gql:generate-configs`. Формат описания экшенов должен совпадать с [базовым типом `TActionConfig`](scripts/generateGQLConfigs/types.ts) и находиться в [соответствующем конфиге](src/lib/gqlConfig/config.ts).

`enum`-списки в чистом виде из сгенерированных типов лучше избегать, потому что при добавлении в них новых значений на фронте нужно сразу же фиксить коллизии, если используется где-то проход по ключам этого списка. Поэтому нужно ручками задавать перечисление в константе (это важно) и уже потом реиспользовать.

## Управление состоянием

Для управления состоянием используется [mobx](https://mobx.js.org/README.html) с оберткой [для реакта](https://github.com/mobxjs/mobx-react). Для хранения общих данных приложения есть глобальные сторы. Их можно получить через функцию `getStore`.

## Стилизация

Для стилизации используются [css-modules](https://github.com/css-modules/css-modules). Объект стилей типизируется через [typescript-plugin-css-modules](https://github.com/mrmckeb/typescript-plugin-css-modules).

## Линтинг

Линтинг осуществляется с помощью `eslint`

## Контроллеры

Если компонент реализуют в себе сложную логику, эту логику необходимо вынести на уровень контроллера. Это позволит разбить общее полотно кода на часть визуализации и часть с логикой (\*VC-подход).

Для работы с контроллерами в утилитах есть функционал:

- хок `withIsolatedScope` позволяет создать новый скоуп
- хук `useCreateScoped` при маунте компонента создает контроллер и удаляет его при анмаунте
- хук `useScoped` позволяет получить созданный ранее контроллер из текущего скоупа
- хук `useCreateTransient` работает аналогично `useCreateScoped`, но не добавляет созданный контроллер в скоуп

Контроллеры должны наследоваться от [`BaseController`](src/lib/controller/base.ts). У базового класса контроллера существует несколько необходимых для этого методов:

- `onCreate`, `onDestroy` - колбеки, которые вызываются соответственно сразу после добавления и прямо перед удалением подконтроллера
- методы `addSubController` и `addSubControllers` - создает дочерние контроллеры и добавляет в скоуп
- метод `removeSubController` - удаляет дочерний контроллер из скоупа
- метод `getScoped` - получает созданный ранее контроллер из скоупа
- метод `hasScoped` - позволяет узнать существует ли контроллер в текущем скоупе

Внутри одного скоупа невозможно дважды создать один контроллер. Для обхода этого ограничения в зависимости от конкретного кейса можно использовать `withIsolatedScope` или `useCreateTransient`

## Дочерние контроллеры

Подконтроллеры существуют для того, чтобы разбивать контроллер на логические части для удобства чтения и редактирования кода. Дочерние контроллеры по функционалу ничем не отличаются от родительских. Иерархия нужна только для зачистки зависимостей. При удалении контроллера автоматически удаляются все его дочерние контроллеры.
