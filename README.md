# Клиентский бойлерплейт

## Старт

- `yarn install`
- создать необходимые `env`-файлы по примеру (`.env.example`):
  - `.env.development` - используется для `dev` сборки (проверить, что `WITH_HMR=false`)
  - `.env.production` - используется для `prod` сборки (проверить, что нет `WITH_HMR`, установлены `NODE_ENV` и `OUTPUT_PATH` для прод-ассетов)

## Скрипты

- `yarn build:<env>` - сборка ассетов для среды
- `yarn lint` - линтинг
- `yarn schema:generate-types` - генерация типов для GraphQL (необходимо активное подключение к gql-сервису, адрес которого указан в `codegen.yml`)
- `yarn start` - запуск дев-сервера (без HMR)
- `yarn start:hot` - запуск дев-сервера (с HMR)
- `yarn start:prod` - запуск `production` сервера

## Роутинг и страницы

## Сервисы

В процессе построения приложения необходимо обеспечить изоляцию скоупа при каждом запросе пользователя. Для этого все сервисы инициализируются с помощью `ServicesManager`. Каждый сервис наследуется от базового класса сервиса, который принимает ссылку на корневой менеджер и сохраняет ее. Таким способом обеспечивается доступ к другим сервисам из какого-либо сервиса, контроллера или плагина. Для получения сервисов в самом компоненте имеются хук и хок.

## Backend API - GraphQL

Для работы с GraphQL используется сервис [Apollo](https://www.apollographql.com/docs/react/) и сервис-надстройка над ним для удобства оперирования с экшенами.
Чтобы использовать типизацию `gql`, нужно сначала сгенерировать gql-типы на основании схемы, которую предоставляет backend, и на основании самих экшенов, которые описываются в отдельной папке (`lib/gql`). Для этого имеется скрипт `schema:generate-types`.
Для использования самих экшенов есть сервис [`GraphglAPI`](src/lib/services/graphqlAPI.ts). Он нужен в основном для инкапсуляции логики обработки ошибок исполнения экшна, выбрасывания оповещений и переключения состояний. Для его использования нужно генерировать экшны с помощью отдельного скрипта - `gql:generate-configs`. Формат описания экшенов должен совпадать с [базовым типом `TActionConfig`](scripts/generateGQLConfigs/types.ts) и находиться в [соответствующем конфиге](src/lib/gqlConfig/config.ts).

`enum`-списки в чистом виде из сгенерированных типов лучше избегать, потому что при добавлении в них новых значений на фронте нужно сразу же фиксить коллизии, если используется где-то проход по ключам этого списка. Поэтому нужно ручками задавать перечисление в константе (это важно) и уже потом реиспользовать.

## Управление состоянием

Для управления состоянием используется [mobx](https://mobx.js.org/README.html) с оберткой [для реакта](https://github.com/mobxjs/mobx-react). Для нормальной регидратации приложения и стора необходимо, чтобы каждый из дочерних сторов, относительно родительского, можно было сериализовать. Поэтому при добавлении новой сущности в корневой стор необходимо имплементировать базовый публичный метод `serialize` (см. `CStore` в `src/lib/store/types`), который вернет нативный js-объект с наблюдаемыми св-вами. Помимо этого новый стор необходимо добалять в св-во `childStores` корневого стора.

## Стилизация

Для стилизации используется [react-jss](https://cssinjs.org/react-jss/?v=v10.0.4). В текущей версии имеются проблемы с типизацией основного хока, поэтому был написан кастомный, который находится в `src/lib/HOCs/withStyles`. Сигнатура ф-ции такая же, как и в исходной имплементаци.

## Линтинг

Линтинг осуществляется с помощью `eslint`

## Контроллеры

Если компонент реализуют в себе сложную логику, эту логику необходимо вынести на уровень контроллера. Это позволит разбить общее полотно кода на часть визуализации и часть с логикой (\*VC-подход). Для этого в утилитах контейнера имеется функционал, который позволяет:

- инициализировать контекст контроллера;
- создать хук и хок для получения контроллера;
- создать хук и хок для получения инстансов подконтроллеров по их классам;

Все это находится в утилите [`controllerHelpersBuilder`](src/lib/utils/controllerHelpersBuilder/index.ts). Пример использования данной утилиты вы можете найти на странице [`Example`](src/containers/ExamplePage/index.tsx).

## Подконтроллеры

Подконтроллеры существуют для того, чтобы разбивать контроллер на логические части для удобства чтения и редактирования кода. Кроме того, разбиение контроллера позволяет управлять его подконтроллерами (добавлять контроллер в пул подконтроллеров, если он необходим для использования компонента и соответственно удалять его, если работа с этой частью компонента завершена)

Для управления подконтроллерами, необходимо, чтобы родительский и дочерние контроллеры наследовались от [`BaseController`](src/lib/controller/base.ts). У базового класса контроллера существует несколько необходимых для этого методов, их описание есть внутри. Основное:

- подконтроллер хранит в себе ссылки на родительский (`parentController`) и корневой (`rootController`) контроллеры
- метод `addSubController` - добавляет подконтроллер;
- метод `removeSubControllerInstance` - удаляет инстанс подконтроллера из пула по его классу;
- `onCreate`, `onDestroy` - колбеки, которые вызываются соответственно сразу после добавления и прямо перед удалением подконтроллера

Контроллеры имеют статическое поле `NAME`, которое должно являться литералом, чтобы типизация при подключении подконтроллеров в компонент работала корректно.

Имена подконтроллеров хранятся в dot-нотации, т.е. `rootName.parentName.name`, это необходимо для случаев когда в дереве подконтроллеров в разных местах могут существовать контроллеры с одинаковым собственным названием. Для генерации имени подконтроллера исходя из родительских и наоборот для получения всех имен контроллеров из последовательности существует форматтер [`nameSubControllers`](src/lib/utils/formatters/nameSubControllers.ts).

Статические поля подконтроллера (в том числе имя) должны быть объявлены в отдельном файле и затем импортированы в контроллер для того, чтобы избежать циклических зависимостей при сборке.

Для использования подконтроллеров в компонентах в утилиту [`controllerHelpersBuilder`](src/lib/utils/controllerHelpersBuilder/index.ts) была добавлена генерация соответствующих хука и хока.

Пример реализации подконтроллера есть на странице [`Example`](src/pages/Example/index.tsx).
